<!-- Radar Chart – WordPress embed -->
<div id="radar-chart-page">
  <h1>MPC History Radar Chart</h1>

  <div class="controls">
    <div class="control-group">
      <h2>Select First Date</h2>
      <label for="yearA">Year</label>
      <select id="yearA"></select>
      <label for="monthA" style="margin-top: 0.6rem;">Month</label>
      <select id="monthA"></select>
    </div>

    <div class="control-group">
      <h2>Select Second Date</h2>
      <label for="ateB">Year</label>
      <select id="yearB"></select>
      <label for="monthB" style="margin-top: 0.6rem;">Month</label>
      <select id="monthB"></select>
    </div>
  </div>

  <div id="dataNote">
    <strong>Note:</strong> When data for the selected month is not available, the graph uses the newest available data from previous months.
  </div>

  <div id="radarWrap">
    <canvas id="radarCanvas"></canvas>
  </div>

  <div id="groupLegend"></div>

  <div id="error" role="alert"></div>
</div>

<style>
  :root {
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    --color-main: #7e0a0d;
    --color-second: #ebc6c0;
    --color-third: #bebebe;
    --color-muted: #787878;
    --color-deep: #161c4e;
    --color-chart1: #376092;
    --color-chart2: #82AEB1;
    --color-chart3: #015555;
    --color-chart4: #4099ED;
    color-scheme: light;
  }

  body {
    margin: 0;
    padding: 1.5rem;
    background: linear-gradient(135deg, var(--color-second) 0%, #ffffff 55%);
    color: #1f1f1f;
  }

  #radar-chart-page {
    max-width: 1100px;
    margin: 0 auto;
    background: #ffffff;
    border-radius: 12px;
    padding: 1.75rem 1.5rem 2rem;
    box-shadow: 0 12px 30px rgba(126, 10, 13, 0.12);
    border: 1px solid var(--color-third);
  }

  h1 {
    margin-top: 0;
    font-size: 1.6rem;
    text-align: center;
    color: var(--color-main);
  }

  #radar-chart-page .controls {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    gap: 1rem;
    margin-bottom: 1.25rem;
  }

  .control-group {
    border-radius: 10px;
    padding: 0.75rem 0.9rem;
    background: #fff7f6;
    border: 1px solid var(--color-second);
  }

  .control-group h2 {
    font-size: 0.95rem;
    margin: 0 0 0.4rem;
    font-weight: 600;
    color: var(--color-deep);
  }

  label {
    display: block;
    font-size: 0.85rem;
    margin-bottom: 0.35rem;
    color: var(--color-deep);
    font-weight: 500;
  }

  select {
    width: 100%;
    padding: 0.35rem 0.5rem;
    border-radius: 6px;
    border: 1px solid var(--color-third);
    font-size: 0.9rem;
    background: #ffffff;
    color: #1f1f1f;
    box-sizing: border-box;
  }

  select:focus {
    outline: none;
    border-color: var(--color-main);
    box-shadow: 0 0 0 2px rgba(126, 10, 13, 0.1);
  }

  #radarWrap {
    position: relative;
    height: 655px;
    background: white;
    border-radius: 8px;
    margin: 1rem 0;
  }

  #radarCanvas {
    width: 100% !important;
    height: 100% !important;
    display: block;
  }

  .note {
    font-size: 0.78rem;
    color: var(--color-muted);
    margin-top: 0.6rem;
    text-align: right;
  }

  #dataNote {
    font-size: 0.85rem;
    color: var(--color-deep);
    background-color: #f5f5f5;
    border-left: 4px solid var(--color-main);
    padding: 0.75rem 1rem;
    margin: 1rem 0;
    border-radius: 4px;
    line-height: 1.5;
  }

  #dataNote strong {
    color: var(--color-main);
    font-weight: 600;
  }

  #error {
    color: var(--color-main);
    font-size: 0.85rem;
    margin-top: 0.75rem;
    display: none;
  }

  #groupLegend {
    display: flex;
    flex-wrap: wrap;
    gap: 1.2rem;
    margin-top: 1.25rem;
    padding-top: 1rem;
    border-top: 1px solid var(--color-third);
    justify-content: center;
  }

  .legend-group {
    display: flex;
    align-items: center;
    gap: 0.6rem;
    font-size: 0.85rem;
  }

  .legend-color-box {
    flex-shrink: 0;
    width: 14px;
    height: 14px;
    border-radius: 2px;
  }

  .legend-group-name {
    font-weight: 500;
    color: var(--color-deep);
  }

  .legend-items {
    display: none;
  }
</style>

<!-- Chart.js CDN (no GitHub links) -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
/**
 * Concentric Bands Plugin for Chart.js Radar Charts
 * 
 * This plugin draws filled polygonal bands behind the radar chart to create
 * a subtle layered background effect. The bands are drawn from outer radius
 * toward the center with customizable colors.
 * 
 * The plugin uses beforeDatasetsDraw hook to ensure bands appear behind
 * the data lines while grid lines remain visible on top.
 */
const concentricBandsPlugin = {
  id: 'concentricBands',
  beforeDatasetsDraw(chart, args, options) {
    const { ctx, scales: { r } } = chart;
    
    if (!r) return; // Ensure radial scale exists
    
    const centerX = r.xCenter;
    const centerY = r.yCenter;
    const outerRadius = r.drawingArea;
    const labelCount = chart.data.labels.length;
    
    // Band colors from outer to inner - using provided palette
    // Main: #7e0a0d (red), Secondary: #ebc6c0 (light pink), #bebebe (grey), #787878 (dark grey), #161C4E (navy)
    // Accent: #376092 (blue), #82AEB1 (teal), #015555 (dark teal), #4099ED (light blue)
    const bandColors = [
      'rgba(235, 198, 192, 0.25)', // outer: light pink (#ebc6c0)
      'rgba(190, 190, 190, 0.25)', // mid-outer: grey (#bebebe)
      'rgba(120, 120, 120, 0.20)', // mid-inner: dark grey (#787878)
      'rgba(130, 174, 177, 0.25)'  // inner: teal (#82AEB1)
    ];
    
    const bandCount = bandColors.length;
    
    // Draw bands from outer to inner so inner bands overlay outer ones
    for (let b = 0; b < bandCount; b++) {
      // Calculate radius for this band (outer edge)
      const outerBandRadius = outerRadius * ((bandCount - b) / bandCount);
      // Calculate radius for inner edge of this band
      const innerBandRadius = outerRadius * ((bandCount - b - 1) / bandCount);
      
      ctx.save();
      ctx.globalAlpha = 0.5; // Soften the look with transparency
      ctx.fillStyle = bandColors[b];
      
      // Draw the outer polygon
      ctx.beginPath();
      for (let i = 0; i < labelCount; i++) {
        const angle = (Math.PI * 2 * i) / labelCount - Math.PI / 2;
        const x = centerX + Math.cos(angle) * outerBandRadius;
        const y = centerY + Math.sin(angle) * outerBandRadius;
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.closePath();
      ctx.fill();
      
      // If not the innermost band, cut out the inner polygon
      if (b < bandCount - 1) {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        for (let i = 0; i < labelCount; i++) {
          const angle = (Math.PI * 2 * i) / labelCount - Math.PI / 2;
          const x = centerX + Math.cos(angle) * innerBandRadius;
          const y = centerY + Math.sin(angle) * innerBandRadius;
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        ctx.fill();
      }
      
      ctx.restore();
    }
  }
};

// Plugin to draw background sections with boundaries at 0 and 1 (DYNAMIC with mapper)
const sectionBackgroundPlugin = {
  id: 'sectionBackground',
  beforeDatasetsDraw(chart) {
    const { ctx, scales: { r } } = chart;
    if (!r) return;

    const centerX = r.xCenter;
    const centerY = r.yCenter;
    const outerRadius = r.drawingArea;
    const labelCount = chart.data.labels.length;

    // Get the mapper stored on the chart
    const mapper = chart._mapper;
    if (!mapper) return;

    // Map the key values (0 and 1) using the stored mapper
    // These return positions in the 0-1 range that Chart.js uses
    const mappedZero = mapper.mapValue(0);
    const mappedOne = mapper.mapValue(1);

    // Convert mapped values to radii
    const getRadiusForMappedValue = (mappedVal) => {
      return mappedVal * outerRadius;
    };

    const r0 = getRadiusForMappedValue(mappedZero);  // radius where original value = 0
    const r1 = getRadiusForMappedValue(mappedOne);   // radius where original value = 1

    // Helper to draw a filled circle (for center)
    const drawCircle = (radius, color) => {
      if (radius <= 0) return;
      ctx.save();
      ctx.fillStyle = color;
      ctx.beginPath();
      for (let i = 0; i < labelCount; i++) {
        const angle = (Math.PI * 2 * i) / labelCount - Math.PI / 2;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    };

    // Helper to draw a ring section
    const drawRing = (innerR, outerR, color) => {
      if (outerR <= innerR || outerR <= 0) return;
      ctx.save();
      ctx.fillStyle = color;

      // Outer polygon
      ctx.beginPath();
      for (let i = 0; i < labelCount; i++) {
        const angle = (Math.PI * 2 * i) / labelCount - Math.PI / 2;
        const x = centerX + Math.cos(angle) * outerR;
        const y = centerY + Math.sin(angle) * outerR;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();

      // Cut inner polygon
      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath();
      for (let i = 0; i < labelCount; i++) {
        const angle = (Math.PI * 2 * i) / labelCount - Math.PI / 2;
        const x = centerX + Math.cos(angle) * innerR;
        const y = centerY + Math.sin(angle) * innerR;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
      ctx.restore();
    };

    // Draw from outer to inner to avoid overwriting
    // Region > 1
    if (r1 < outerRadius) {
      drawRing(r1, outerRadius, 'rgba(244, 211, 208, 0.5)'); // light red outer (>1 area), 50% opacity
    }
    // Region 0-1
    if (r0 < r1) {
      drawRing(r0, r1, 'rgba(190, 190, 190, 0.7)'); // grey middle (0-1), 70% opacity
    }
    // Region < 0
    if (r0 > 0) {
      drawCircle(r0, 'rgba(173, 216, 230, 0.7)'); // light blue center (< 0), 70% opacity
    }

    // Draw boundary lines at 0 and 1
    ctx.save();
    ctx.strokeStyle = 'rgba(100, 100, 100, 0.35)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([5, 4]);
    const drawBoundaryLine = (radius) => {
      if (radius <= 0 || radius >= outerRadius) return;
      ctx.beginPath();
      for (let i = 0; i < labelCount; i++) {
        const angle = (Math.PI * 2 * i) / labelCount - Math.PI / 2;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.stroke();
    };
    if (r0 > 0 && r0 < outerRadius) drawBoundaryLine(r0);
    if (r1 > 0 && r1 < outerRadius) drawBoundaryLine(r1);
    ctx.restore();
  }
};

// Plugin to draw circular grid lines based on mapper ticks (DYNAMIC)
const evenGridLinesPlugin = {
  id: 'evenGridLines',
  beforeDatasetsDraw(chart) {
    const { ctx, scales: { r } } = chart;
    
    if (!r) return;
    
    const centerX = r.xCenter;
    const centerY = r.yCenter;
    const outerRadius = r.drawingArea;
    const labelCount = chart.data.labels.length;
    
    // Get the mapper stored on the chart
    const mapper = chart._mapper;
    if (!mapper) return;

    // Use the tick stops from the mapper to draw grid lines
    const tickStops = mapper.tickStops || [0, 1];
    
    ctx.save();
    ctx.strokeStyle = 'rgba(190, 190, 190, 0.3)';
    ctx.lineWidth = 1;
    
    tickStops.forEach(mappedTick => {
      const radius = mappedTick * outerRadius;
      if (radius <= 0 || radius >= outerRadius) return;
      
      ctx.beginPath();
      for (let j = 0; j < labelCount; j++) {
        const angle = (Math.PI * 2 * j) / labelCount - Math.PI / 2;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;
        if (j === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.closePath();
      ctx.stroke();
    });
    
    // Draw angle lines (radial lines from center)
    ctx.strokeStyle = 'rgba(190, 190, 190, 0.3)';
    ctx.lineWidth = 1;
    
    for (let i = 0; i < labelCount; i++) {
      const angle = (Math.PI * 2 * i) / labelCount - Math.PI / 2;
      const x = centerX + Math.cos(angle) * outerRadius;
      const y = centerY + Math.sin(angle) * outerRadius;
      
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(x, y);
      ctx.stroke();
    }
    
    ctx.restore();
  }
};

// Register the plugins globally with Chart.js
// Chart.register(concentricBandsPlugin); // Disabled for clean background
Chart.register(sectionBackgroundPlugin);
Chart.register(evenGridLinesPlugin);

// Run after DOM is ready so getElementById finds elements
document.addEventListener('DOMContentLoaded', () => {
  (async function() {

    // -------------------------------------------------------
    // 1. CONFIG: where to load the CSV
    // -------------------------------------------------------
    // If CSV is in the SAME folder as this HTML block:
    //   const DATA_CSV_URL = "MPCRadarDataTest.csv";
    //
    // If CSV is a published Google Sheet CSV:
    //   const DATA_CSV_URL = "https://docs.google.com/spreadsheets/.../pub?output=csv";
    //
    // Currently using your Google Sheet (no GitHub link here):
    // const DATA_CSV_URL = "MPCRadarDataTest.csv";
    const DATA_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQN43fsnxjkUioVKd1G3DxcCAn0L55xgVklcaGVlwUDKLQ4RriQioilqxnDgoJ4UTjjVgp45Htk7VfT/pub?output=csv";

    console.log("Trying to load CSV from:", DATA_CSV_URL);

    // DOM references
    const yearASelect  = document.getElementById("yearA");
    const monthASelect = document.getElementById("monthA");
    const yearBSelect  = document.getElementById("yearB");
    const monthBSelect = document.getElementById("monthB");
    const errorBox     = document.getElementById("error");
    const canvasEl     = document.getElementById("radarCanvas");

    // quick guard: make sure required elements exist
    if (!yearASelect || !monthASelect || !yearBSelect || !monthBSelect || !errorBox || !canvasEl) {
      console.error("Required DOM elements not found. Check IDs: yearA, monthA, yearB, monthB, radarCanvas, error");
      if (errorBox) {
        errorBox.textContent = "Page missing required elements. Check page markup.";
        errorBox.style.display = "block";
      }
      return;
    }

    // Internal data
    let radarChart = null;
    let indicators = [];
    let entries    = [];
    let sortedEntries = [];
    let globalMinMax = { min: 0, max: 1 };

    const MONTH_ORDER = ["JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"];

    // Data grouping configuration
    const indicatorGroups = {
      'Inflation': {
        color: '#E8956F',
        indicators: [
          'CPI Inflation',
          'Core Inflation',
          'Food Price Inflation',
          'Services Inflation',
          'Household Inflation Expectations',
          'Input PPI',
          'Corporate GOS'
        ]
      },
      'Labour Market': {
        color: '#6CA6CD',
        indicators: [
          'Current Wage Growth',
          'Median Pay Growth',
          'Participation Rate',
          'V/U',
          'Unemployment Rate'
        ]
      },
      'Macro-Finance': {
        color: '#6FBD92',
        indicators: [
          'Savings Ratio',
          'Consumer Confidence',
          'GDP',
          'FTSE100'
        ]
      }
    };

    // Helper: Get the group and color for an indicator
    function getIndicatorGroup(indicator) {
      for (const [groupName, groupData] of Object.entries(indicatorGroups)) {
        if (groupData.indicators.includes(indicator)) {
          return { groupName, color: groupData.color };
        }
      }
      return { groupName: 'Other', color: '#999999' };
    }

    // Create colored labels plugin definition
    const coloredLabelsPlugin = {
      id: 'coloredLabels',
      afterDatasetsDraw(chart) {
        const { ctx, scales: { r } } = chart;
        if (!r || !chart.data.labels) return;

        const centerX = r.xCenter;
        const centerY = r.yCenter;
        const outerRadius = r.drawingArea;
        const labelCount = chart.data.labels.length;
        if (!labelCount) return;

        // Increased distance to prevent overlapping
        const labelDistance = outerRadius + 45;

        chart.data.labels.forEach((label, i) => {
          if (!label) return;
          
          const angle = (Math.PI * 2 * i) / labelCount - Math.PI / 2;
          const x = centerX + Math.cos(angle) * labelDistance;
          const y = centerY + Math.sin(angle) * labelDistance;

          const groupInfo = getIndicatorGroup(label);
          const color = groupInfo.color || '#999999';

          // Better text properties
          ctx.save();
          ctx.fillStyle = color;
          ctx.font = '500 11px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          // Add slight shadow for better readability
          ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
          ctx.shadowBlur = 3;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
          
          ctx.fillText(label, x, y);
          ctx.restore();
        });
      }
    };

    // Don't register the custom labels plugin - use Chart.js built-in instead
    // Chart.register(coloredLabelsPlugin);

    function showError(msg) {
      errorBox.textContent = msg;
      errorBox.style.display = "block";
    }
    function hideError() {
      errorBox.textContent = "";
      errorBox.style.display = "none";
    }

    function parseCsv(text) {
      const lines = text.trim().split(/\r?\n/);
      const rows = lines.map(line => line.split(","));
      console.log("CSV rows (including header):", rows.length);
      return rows;
    }

    function parseDateStr(dateStr) {
      if (!dateStr) return null;
      const parts = dateStr.trim().split(/\s+/);
      if (parts.length < 2) return null;
      const year = parseInt(parts[0], 10);
      const monthCode = parts[1].toUpperCase();
      if (isNaN(year)) return null;
      if (!MONTH_ORDER.includes(monthCode)) {
        console.warn("Unknown month code in Date:", dateStr);
        return null;
      }
      return { year, monthCode };
    }

    async function loadData() {
      const res = await fetch(DATA_CSV_URL);
      console.log("Fetch status:", res.status, res.statusText);
      if (!res.ok) {
        throw new Error("Failed to fetch CSV (" + res.status + " " + res.statusText + "). Check DATA_CSV_URL and file path.");
      }
      const csvText = await res.text();
      const rows = parseCsv(csvText);
      if (rows.length < 2) {
        throw new Error("CSV has no data rows (rows.length < 2).");
      }

      const headers = rows[0];
      const body    = rows.slice(1);

      console.log("Header columns:", headers);

      // 1st col: Date, rest: indicators
      indicators = headers.slice(1);
      console.log("Indicators:", indicators);

      entries = body.map(cols => {
        const dateStr = cols[0];
        const parsed  = parseDateStr(dateStr);
        if (!parsed) return null;

        const numericValues = cols.slice(1).map(v => {
          // Skip #VALUE! and empty strings
          if (v === "#VALUE!" || (typeof v === "string" && v.trim() === "")) {
            return null;
          }
          const val = parseFloat(v);
          return Number.isNaN(val) ? 0 : val;
        });

        return {
          dateStr,
          year: parsed.year,
          monthCode: parsed.monthCode,
          values: numericValues
        };
      }).filter(e => e !== null);

      // Sort entries chronologically for backfill logic
      sortedEntries = [...entries].sort((a, b) => {
        if (a.year !== b.year) return a.year - b.year;
        return MONTH_ORDER.indexOf(a.monthCode) - MONTH_ORDER.indexOf(b.monthCode);
      });

      console.log("Parsed entries:", entries.length);
      if (!entries.length) {
        throw new Error("No valid entries parsed from CSV. Check Date format (e.g. '1989 JAN').");
      }

      // Compute global min/max across the entire dataset for fixed scaling
      globalMinMax = computeGlobalMinMax();
    }

    function uniqueYears() {
      const ys = new Set(entries.map(e => e.year));
      return Array.from(ys).sort((a,b) => a - b);
    }

    function monthsForYear(year) {
      const set = new Set(
        entries.filter(e => e.year === year).map(e => e.monthCode)
      );
      const months = Array.from(set);
      months.sort((a,b) => MONTH_ORDER.indexOf(a) - MONTH_ORDER.indexOf(b));
      return months;
    }

    function getValuesForYearMonth(year, monthCode) {
      if (!sortedEntries.length) {
        return {
          values: indicators.map(() => 0),
          sources: indicators.map(() => "N/A")
        };
      }

      const targetIdx = sortedEntries.findIndex(r => r.year === year && r.monthCode === monthCode);
      const baseValues = (targetIdx !== -1)
        ? [...sortedEntries[targetIdx].values]
        : indicators.map(() => null);

      const startBackfillIdx = (targetIdx !== -1) ? targetIdx - 1 : sortedEntries.length - 1;

      const values = [];
      const sources = [];

      baseValues.forEach((v, idx) => {
        if (v !== null && v !== undefined) {
          values.push(v);
          sources.push("N/A");
          return;
        }
        for (let i = startBackfillIdx; i >= 0; i--) {
          const candidate = sortedEntries[i].values[idx];
          if (candidate !== null && candidate !== undefined) {
            values.push(candidate);
            sources.push(sortedEntries[i].dateStr || "N/A");
            return;
          }
        }
        values.push(0);
        sources.push("N/A");
      });

      return { values, sources };
    }

    function computeGlobalMinMax() {
      let min = Infinity;
      let max = -Infinity;
      entries.forEach(e => {
        e.values.forEach(v => {
          if (typeof v === "number" && !Number.isNaN(v)) {
            if (v < min) min = v;
            if (v > max) max = v;
          }
        });
      });
      if (min === Infinity) min = 0;
      if (max === -Infinity) max = 1;
      return { min, max };
    }

    function buildSegmentMapper(minVal, maxVal) {
      const NEG_FRAC = 0.40; // below 0 takes 40% of radius
      const MID_FRAC = 0.20; // 0-1 takes 20%
      const POS_FRAC = 0.40; // above 1 takes 40%

      const safeMin = (typeof minVal === 'number' && !Number.isNaN(minVal)) ? minVal : 0;
      const safeMax = (typeof maxVal === 'number' && !Number.isNaN(maxVal)) ? maxVal : 1;
      const spanNeg = safeMin < 0 ? -safeMin : 0;
      const spanPos = safeMax > 1 ? (safeMax - 1) : 0;

      const mapValue = (v) => {
        if (v === null || typeof v !== 'number' || Number.isNaN(v)) return null;
        if (v <= 0) {
          if (spanNeg === 0) return 0;
          const t = (v - safeMin) / (0 - safeMin); // 0→1 across negative span
          return Math.max(0, Math.min(1, t * NEG_FRAC));
        }
        if (v <= 1) {
          const t = v; // 0–1
          return NEG_FRAC + t * MID_FRAC;
        }
        if (spanPos === 0) return 1;
        const t = (v - 1) / spanPos; // 0→1 above 1
        return Math.max(0, Math.min(1, NEG_FRAC + MID_FRAC + t * POS_FRAC));
      };

      // Inverse: convert mapped value back to original value
      const unmapValue = (mapped) => {
        if (mapped <= NEG_FRAC) {
          // In the <0 region
          if (spanNeg === 0) return safeMin;
          const t = mapped / NEG_FRAC; // 0→1 within negative fraction
          return safeMin + t * (0 - safeMin);
        }
        if (mapped <= NEG_FRAC + MID_FRAC) {
          // In the 0-1 region
          const t = (mapped - NEG_FRAC) / MID_FRAC; // 0→1 within middle fraction
          return t; // returns 0-1
        }
        // In the >1 region
        if (spanPos === 0) return safeMax;
        const t = (mapped - NEG_FRAC - MID_FRAC) / POS_FRAC; // 0→1 within positive fraction
        return 1 + t * spanPos;
      };

      const tickStops = [0, 1];
      const pushTick = (realVal) => {
        const mapped = mapValue(realVal);
        if (mapped === null || Number.isNaN(mapped)) return;
        if (!tickStops.some(t => Math.abs(t - mapped) < 1e-6)) {
          tickStops.push(mapped);
        }
      };

      pushTick(safeMin);
      pushTick(0);
      pushTick(1);
      pushTick(safeMax);

      tickStops.sort((a, b) => a - b);

      return {
        mapValue,
        unmapValue,
        tickStops,
        scaleMin: 0,
        scaleMax: 1,
        originalMin: safeMin,
        originalMax: safeMax,
        NEG_FRAC,
        MID_FRAC,
        POS_FRAC
      };
    }

    // Helper: Compute min and max from the currently displayed data arrays.
    function getDisplayedMinMax(dataArrays) {
      let min = Infinity;
      let max = -Infinity;
      dataArrays.forEach(arr => {
        arr.forEach(v => {
          if (typeof v === "number" && !Number.isNaN(v)) {
            if (v < min) min = v;
            if (v > max) max = v;
          }
        });
      });
      if (min === Infinity) min = 0;
      if (max === -Infinity) max = 100;
      return { min, max };
    }

    // Helper: Compute symmetric tick stops centered on 0.
    function computeTickStops(minDisplayed, maxDisplayed) {
      const safeMin = (typeof minDisplayed === 'number' && !Number.isNaN(minDisplayed)) ? minDisplayed : 0;
      const safeMax = (typeof maxDisplayed === 'number' && !Number.isNaN(maxDisplayed)) ? maxDisplayed : 0;
      const maxAbsValue = Math.max(Math.abs(safeMin), Math.abs(safeMax));
      
      const positiveCandidates = [
        [0, 0.25, 0.5, 0.75, 1],
        [0, 0.25, 0.5, 0.75, 1, 3],
        [0, 0.25, 0.5, 0.75, 1, 3, 5],
        [0, 0.25, 0.5, 0.75, 1, 3, 5, 10],
        [0, 0.25, 0.5, 0.75, 1, 3, 5, 10, 20],
        [0, 0.25, 0.5, 0.75, 1, 3, 5, 10, 20, 50],
        [0, 0.25, 0.5, 0.75, 1, 3, 5, 10, 20, 50, 100]
      ];

      let positiveStops = null;
      for (const stops of positiveCandidates) {
        const maxStop = stops[stops.length - 1];
        if (maxAbsValue <= maxStop) {
          positiveStops = stops;
          break;
        }
      }

      if (!positiveStops) {
        positiveStops = [...positiveCandidates[positiveCandidates.length - 1]];
        const extensions = [200, 500, 1000, 2000, 5000, 10000];
        for (const ext of extensions) {
          positiveStops.push(ext);
          if (maxAbsValue <= ext) break;
        }
      }

      if (safeMin < 0) {
        const negativeStops = positiveStops.slice(1).map(v => -v).reverse();
        return [...negativeStops, ...positiveStops];
      }

      return positiveStops;
    }

    function populateYearSelect(selectEl) {
      const years = uniqueYears();
      console.log("Years detected:", years);
      selectEl.innerHTML = "";
      years.forEach(y => {
        const opt = document.createElement("option");
        opt.value = y;
        opt.textContent = y;
        selectEl.appendChild(opt);
      });
      if (years.length) {
        selectEl.value = years[years.length - 1];
      }
    }

    function populateMonthSelect(selectEl, year) {
      const months = monthsForYear(year);
      console.log("Months for year", year, ":", months);
      selectEl.innerHTML = "";
      months.forEach(m => {
        const opt = document.createElement("option");
        opt.value = m;
        opt.textContent = m;
        selectEl.appendChild(opt);
      });
      if (months.length) {
        selectEl.value = months[months.length - 1];
      }
    }

    function initSelectors() {
      populateYearSelect(yearASelect);
      populateYearSelect(yearBSelect);

      const yearA = parseInt(yearASelect.value, 10);
      // Set default for second line to 2020 OCT if available
      const availableYears = uniqueYears();
      if (availableYears.includes(2020)) {
        yearBSelect.value = 2020;
      }
      const yearB = parseInt(yearBSelect.value, 10);

      populateMonthSelect(monthASelect, yearA);
      populateMonthSelect(monthBSelect, yearB);
      // Try to select OCT for second line if available
      const monthsB = monthsForYear(yearB);
      if (monthsB.includes('OCT')) {
        monthBSelect.value = 'OCT';
      }
    }

    function renderGroupLegend() {
      const legendEl = document.getElementById("groupLegend");
      legendEl.innerHTML = "";

      for (const [groupName, groupData] of Object.entries(indicatorGroups)) {
        const groupDiv = document.createElement("div");
        groupDiv.className = "legend-group";

        const colorBox = document.createElement("div");
        colorBox.className = "legend-color-box";
        colorBox.style.backgroundColor = groupData.color;

        const contentDiv = document.createElement("div");

        const groupTitle = document.createElement("div");
        groupTitle.className = "legend-group-name";
        groupTitle.textContent = groupName;

        const itemsList = document.createElement("div");
        itemsList.className = "legend-items";
        itemsList.textContent = groupData.indicators.join(", ");

        contentDiv.appendChild(groupTitle);
        contentDiv.appendChild(itemsList);

        groupDiv.appendChild(colorBox);
        groupDiv.appendChild(contentDiv);

        legendEl.appendChild(groupDiv);
      }
    }

    function sanitizeForDisplay(values) {
      return values.map(v => {
        if (v === null) return null;
        if (typeof v === "number" && !Number.isNaN(v)) {
          return v;
        }
        return null;
      });
    }

    function hasBackfilledData(sourcesA, sourcesB) {
      // Check if any data point is backfilled (source date is not 'N/A')
      const hasBackfillA = sourcesA && sourcesA.some(s => s !== 'N/A');
      const hasBackfillB = sourcesB && sourcesB.some(s => s !== 'N/A');
      return hasBackfillA || hasBackfillB;
    }

    function updateNoteVisibility(sourcesA, sourcesB) {
      const noteEl = document.getElementById('dataNote');
      if (!noteEl) return;
      
      if (hasBackfilledData(sourcesA, sourcesB)) {
        noteEl.style.display = 'block';
      } else {
        noteEl.style.display = 'none';
      }
    }

    // Helper: Transform values so that the innermost tick interval is unused.
    function transformForDeadCenter(values, tickStops) {
      if (!tickStops || tickStops.length < 2) {
        return values;
      }
      
      const tick0 = tickStops[0];
      const tick1 = tickStops[1];
      const tickLast = tickStops[tickStops.length - 1];
      const originalSpan = tickLast - tick0;
      const transformedSpan = tickLast - tick1;
      
      return values.map(v => {
        if (v === null || typeof v !== "number" || Number.isNaN(v)) {
          return v;
        }
        if (originalSpan === 0) {
          return tick1;
        }
        return tick1 + (v - tick0) * transformedSpan / originalSpan;
      });
    }

    function initChart() {
      const ctx = canvasEl.getContext("2d");

      const yearA  = parseInt(yearASelect.value, 10);
      const monthA = monthASelect.value;
      const yearB  = parseInt(yearBSelect.value, 10);
      const monthB = monthBSelect.value;

      const resA = getValuesForYearMonth(yearA, monthA);
      const resB = getValuesForYearMonth(yearB, monthB);
      const rawA = resA.values;
      const rawB = resB.values;
      const sourceA = resA.sources;
      const sourceB = resB.sources;
      const sanitizedA = sanitizeForDisplay(rawA);
      const sanitizedB = sanitizeForDisplay(rawB);

      // Calculate min/max from CURRENT selected data, not global
      let currentMin = Infinity;
      let currentMax = -Infinity;
      [...sanitizedA, ...sanitizedB].forEach(v => {
        if (typeof v === "number" && !Number.isNaN(v)) {
          if (v < currentMin) currentMin = v;
          if (v > currentMax) currentMax = v;
        }
      });
      if (currentMin === Infinity) currentMin = 0;
      if (currentMax === -Infinity) currentMax = 1;
      // Expand autoscale range by ±10% of current data range
      const rangeInit = currentMax - currentMin;
      const padInit = (rangeInit === 0)
        ? 0.1 * (Math.abs(currentMax) > 0 ? Math.abs(currentMax) : 1)
        : 0.1 * rangeInit;
      const expandedMin = currentMin - padInit;
      const expandedMax = currentMax + padInit;

      const mapper = buildSegmentMapper(expandedMin, expandedMax);
      const tickStops = mapper.tickStops;
      // Use ORIGINAL data range for the scale, NOT the mapped 0-1 range
      const scaleMin = mapper.originalMin;
      const scaleMax = mapper.originalMax;

      const dataA = sanitizedA.map(v => mapper.mapValue(v));
      const dataB = sanitizedB.map(v => mapper.mapValue(v));

      const chart = new Chart(ctx, {
        type: "radar",
        data: {
          labels: indicators,
          datasets: [
            {
              label: `${yearA} ${monthA}`,
              data: dataA,
              _originalValues: sanitizedA,
              _sourceDates: sourceA,
              borderColor: "#7e0a0d",              // main red
              backgroundColor: "rgba(0, 0, 0, 0)",
              fill: false,
              pointBackgroundColor: "#7e0a0d",
              pointBorderColor: "#ffffff",
              borderWidth: 2.5,
              pointRadius: 5,
              pointBorderWidth: 2,
              spanGaps: true
            },
            {
              label: `${yearB} ${monthB}`,
              data: dataB,
              _originalValues: sanitizedB,
              _sourceDates: sourceB,
              borderColor: "#161C4E",              // secondary navy
              backgroundColor: "rgba(0, 0, 0, 0)",
              fill: false,
              pointBackgroundColor: "#161C4E",
              pointBorderColor: "#ffffff",
              borderWidth: 2.5,
              pointRadius: 5,
              pointBorderWidth: 2,
              spanGaps: true
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          elements: { line: { tension: 0.2 } },
          scales: {
            r: {
              beginAtZero: false,
              min: scaleMin,
              max: scaleMax,
              ticks: { 
                display: false
              },
              afterBuildTicks: function(scale) {
                const chart = scale.chart;
                if (chart._tickStops && chart._tickStops.length > 0) {
                  scale.min = chart._tickStops[0];
                  scale.max = chart._tickStops[chart._tickStops.length - 1];
                  scale.ticks = chart._tickStops.map(value => ({ value }));
                }
              },
              grid: { 
                circular: false,
                display: false,
                drawBorder: false
              },
              pointLabels: {
                display: true,
                color: function(context) {
                  const label = context.label;
                  const group = getIndicatorGroup(label);
                  return (group && group.color) ? group.color : '#999999';
                },
                font: {
                  size: 11,
                  weight: '500'
                },
                padding: 10
              },
              angleLines: {
                display: true,
                color: 'rgba(190, 190, 190, 0.3)'
              }
            }
          },
          plugins: {
            legend: { 
              position: "bottom",
              align: "center",
              labels: {
                font: { size: 11, weight: 600 },
                usePointStyle: true,
                boxWidth: 8,
                padding: 16,
                color: function(context) {
                  const dataset = context.chart?.data?.datasets?.[context.datasetIndex];
                  return (dataset && dataset.borderColor) ? dataset.borderColor : '#161C4E';
                }
              }
            },
            tooltip: { 
              enabled: true,
              callbacks: {
                label: function(context) {
                  const dataset = context.dataset;
                  const originalValues = dataset._originalValues;
                  const sourceDates = dataset._sourceDates;
                  const index = context.dataIndex;
                  const originalValue = (originalValues && index < originalValues.length) 
                    ? originalValues[index] 
                    : null;
                  const sourceDate = (sourceDates && index < sourceDates.length) 
                    ? sourceDates[index] 
                    : 'N/A';
                  
                  // Use actual source date if available, otherwise use dataset label
                  const displayLabel = (sourceDate && sourceDate !== 'N/A') ? sourceDate : dataset.label;
                  
                  if (originalValue === null || originalValue === undefined) {
                    return `${displayLabel}: N/A`;
                  }
                  return `${displayLabel}: ${originalValue}`;
                }
              }
            }
          }
        }
      });
      
      // Store mapper on chart for plugins to access
      chart._mapper = mapper;
      chart._tickStops = tickStops;
      chart._transformValue = (v) => mapper.mapValue(v);
      radarChart = chart;
      
      updateNoteVisibility(sourceA, sourceB);
      // Force a rebuild so ticks and background use mapper on first render
      chart.update();
    }

    function updateChart() {
      if (!radarChart) return;

      const yearA  = parseInt(yearASelect.value, 10);
      const monthA = monthASelect.value;
      const yearB  = parseInt(yearBSelect.value, 10);
      const monthB = monthBSelect.value;

      const resA = getValuesForYearMonth(yearA, monthA);
      const resB = getValuesForYearMonth(yearB, monthB);
      const rawA = resA.values;
      const rawB = resB.values;
      const sourceA = resA.sources;
      const sourceB = resB.sources;
      const sanitizedA = sanitizeForDisplay(rawA);
      const sanitizedB = sanitizeForDisplay(rawB);

      // Calculate min/max from CURRENT selected data, not global
      let currentMin = Infinity;
      let currentMax = -Infinity;
      [...sanitizedA, ...sanitizedB].forEach(v => {
        if (typeof v === "number" && !Number.isNaN(v)) {
          if (v < currentMin) currentMin = v;
          if (v > currentMax) currentMax = v;
        }
      });
      if (currentMin === Infinity) currentMin = 0;
      if (currentMax === -Infinity) currentMax = 1;
      // Expand autoscale range by ±10% of current data range
      const rangeUpd = currentMax - currentMin;
      const padUpd = (rangeUpd === 0)
        ? 0.1 * (Math.abs(currentMax) > 0 ? Math.abs(currentMax) : 1)
        : 0.1 * rangeUpd;
      const expandedMin = currentMin - padUpd;
      const expandedMax = currentMax + padUpd;

      const mapper = buildSegmentMapper(expandedMin, expandedMax);
      const tickStops = mapper.tickStops;

      const dataA = sanitizedA.map(v => mapper.mapValue(v));
      const dataB = sanitizedB.map(v => mapper.mapValue(v));

      radarChart._mapper = mapper;
      radarChart._tickStops = tickStops;
      radarChart._transformValue = (v) => mapper.mapValue(v);

      // Use ORIGINAL data range for the scale display
      radarChart.options.scales.r.min = mapper.originalMin;
      radarChart.options.scales.r.max = mapper.originalMax;

      radarChart.data.datasets[0].label = `${yearA} ${monthA}`;
      radarChart.data.datasets[0].data  = dataA;
      radarChart.data.datasets[0]._originalValues = sanitizedA;
      radarChart.data.datasets[0]._sourceDates = sourceA;

      radarChart.data.datasets[1].label = `${yearB} ${monthB}`;
      radarChart.data.datasets[1].data  = dataB;
      radarChart.data.datasets[1]._originalValues = sanitizedB;
      radarChart.data.datasets[1]._sourceDates = sourceB;

      radarChart.update();
      updateNoteVisibility(sourceA, sourceB);
    }

    // Main init
    try {
      hideError();
      await loadData();
      initSelectors();
      renderGroupLegend();
      initChart();

      yearASelect.addEventListener("change", () => {
        const y = parseInt(yearASelect.value, 10);
        populateMonthSelect(monthASelect, y);
        updateChart();
      });
      yearBSelect.addEventListener("change", () => {
        const y = parseInt(yearBSelect.value, 10);
        populateMonthSelect(monthBSelect, y);
        updateChart();
      });

      monthASelect.addEventListener("change", updateChart);
      monthBSelect.addEventListener("change", updateChart);
    } catch (e) {
      console.error(e);
      showError("Error loading or parsing data: " + e.message);
    }

  })();
});
</script>